<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ğŸ’¾ La donnÃ©e</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="main_files/libs/clipboard/clipboard.min.js"></script>
<script src="main_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="main_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="main_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="main_files/libs/quarto-html/popper.min.js"></script>
<script src="main_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="main_files/libs/quarto-html/anchor.min.js"></script>
<link href="main_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="main_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="main_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="main_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="main_files/libs/bootstrap/bootstrap-d742ed06778eb1a5b2a0b8251afbc0b2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ğŸ’¾ La donnÃ©e</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div id="e98ce8f6" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install <span class="op">-</span>q <span class="op">-</span>r ..<span class="op">/</span>requirements.txt</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Note: you may need to restart the kernel to use updated packages.</code></pre>
</div>
</div>
<section id="de-quoi-avons-nous-besoin" class="level3">
<h3 class="anchored" data-anchor-id="de-quoi-avons-nous-besoin">De quoi avons-nous besoin ?</h3>
<p>Pour mener cette enquÃªte, nous devons constituer les â€œempreintes digitalesâ€ physico-chimiques des produits. Nous avons structurÃ© notre dataset ainsi :</p>
<ul>
<li>ğŸ¯ <strong>La Cible (y) :</strong> Le grade <strong>Nutri-Score</strong> (A, B, C, D, E).</li>
<li>ğŸ§ª <strong>Les Indices (X) :</strong> Les macronutriments bruts (sucre, sel, gras, fibres, protÃ©ines, etc.).</li>
<li>ğŸ·ï¸ <strong>Le Contexte :</strong> La catÃ©gorie du produit (on ne juge pas un fromage comme un soda).</li>
</ul>
</section>
<section id="source-et-fiabilitÃ©-le-dÃ©fi-openfoodfacts" class="level3">
<h3 class="anchored" data-anchor-id="source-et-fiabilitÃ©-le-dÃ©fi-openfoodfacts">Source et FiabilitÃ© : Le dÃ©fi OpenFoodFacts</h3>
<p>Nous avons choisi <strong>OpenFoodFacts</strong>, une base de donnÃ©es collaborative. Ce choix mÃ©thodologique est Ã  double tranchant :</p>
<ul>
<li>âœ… <strong>La Force (RÃ©alisme) :</strong> Câ€™est le reflet du marchÃ© rÃ©el, pas un dataset aseptisÃ© de laboratoire.</li>
<li>âš ï¸ <strong>La Faiblesse (Bruit) :</strong> Câ€™est un chaos de donnÃ©es (erreurs de saisie, unitÃ©s hÃ©tÃ©rogÃ¨nes, doublons). La fiabilitÃ© brute est faible, rendant le <strong>Data Cleaning</strong> plus critique que la modÃ©lisation elle-mÃªme.</li>
</ul>
</section>
<section id="une-dÃ©marche-frugale-assumÃ©e" class="level3">
<h3 class="anchored" data-anchor-id="une-dÃ©marche-frugale-assumÃ©e">Une dÃ©marche â€œFrugaleâ€ assumÃ©e</h3>
<p>Nous avons dÃ©libÃ©rÃ©ment choisi de ne pas travailler sur lâ€™intÃ©gralitÃ© de la base (Big Data), mais sur un Ã©chantillon reprÃ©sentatif.</p>
<ol type="1">
<li><strong>SobriÃ©tÃ© NumÃ©rique :</strong> EntraÃ®ner des modÃ¨les sur des millions de lignes pour un gain de prÃ©cision marginal (0.01%) est un non-sens Ã©cologique.</li>
<li><strong>MÃ©thodologie &gt; Volume :</strong> Nous voulons dÃ©montrer quâ€™un Ã©chantillon propre et des <em>Smart Features</em> battent toujours un gros volume de donnÃ©es bruitÃ©. Cela nous permet de rester agiles et dâ€™itÃ©rer rapidement.</li>
</ol>
<hr>
</section>
<section id="nettoyage-imposer-les-lois-de-la-physique" class="level2">
<h2 class="anchored" data-anchor-id="nettoyage-imposer-les-lois-de-la-physique">ğŸ§¹ Nettoyage : Imposer les lois de la physique</h2>
<p>La premiÃ¨re Ã©tape nâ€™a pas Ã©tÃ© technique, mais <strong>physique</strong>. Pour valider nos ordres de grandeur, nous avons codÃ© des rÃ¨gles immuables :</p>
<ul>
<li>âŒ <strong>La rÃ¨gle des 100% :</strong> Un produit ne peut pas contenir 150g de sucre pour 100g de matiÃ¨re. Nous avons supprimÃ© ou â€œclampÃ©â€ ces aberrations.</li>
<li>ğŸ”¥ <strong>La cohÃ©rence calorique :</strong> Exclusion de tout produit dÃ©passant <strong>900 kcal/100g</strong> (valeur de lâ€™huile pure). Au-delÃ , câ€™est une erreur de saisie.</li>
</ul>
<blockquote class="blockquote">
<p><strong>ğŸš« Traitement radical des valeurs manquantes (NaN)</strong></p>
<p>Nous avons <strong>refusÃ© lâ€™imputation par la moyenne</strong>. <em>Remplacer une valeur manquante par la â€œmoyenne du sucreâ€ nâ€™a aucun sens pour classer un produit rÃ©glementaire.</em></p>
<p><strong>Notre choix :</strong> Si lâ€™information manque, le produit est <strong>Ã©cartÃ© de lâ€™apprentissage</strong>. Câ€™est une approche stricte, mais nÃ©cessaire pour garantir la puretÃ© du modÃ¨le.</p>
</blockquote>
<p>Enfin, pour la lisibilitÃ©, nous avons renommÃ© les colonnes techniques de lâ€™API (ex: <code>energy-kcal_100g</code>) en termes humains (<code>Energie</code>, <code>Sucre</code>), crÃ©ant ainsi notre propre dictionnaire de variables.</p>
<div id="dfa984e5" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Charge l'extension d'autorechargement</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Configure pour tout recharger automatiquement avant chaque exÃ©cution</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> food_analyzer <span class="im">import</span> <span class="op">*</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="stratÃ©gie-daquisition-des-donnÃ©es" class="level3">
<h3 class="anchored" data-anchor-id="stratÃ©gie-daquisition-des-donnÃ©es">âš™ï¸ StratÃ©gie dâ€™aquisition des donnÃ©es</h3>
<p>Pour garantir la fiabilitÃ© et la reproductibilitÃ© du dataset, nous avons implÃ©mentÃ© une logique de collecte dÃ©fensive :</p>
<ul>
<li><p><strong>Gestion intelligente de lâ€™API (Pagination &amp; Rate-Limiting) :</strong> Nous rÃ©cupÃ©rons les donnÃ©es par lots de 50 produits avec des temporisations (<code>sleep</code>) entre les appels.<br>
<em>Pourquoi ?</em> Cette approche contourne les timeouts serveur, respecte les quotas de lâ€™API OpenFoodFacts et Ã©vite le bannissement de notre IP.</p></li>
<li><p><strong>DÃ©tection dâ€™environnement (CI/CD vs Local) :</strong> Le script dÃ©tecte automatiquement sâ€™il tourne sur GitHub Actions (<code>IS_CI</code>).<br>
<em>Pourquoi ?</em> Cela permet de charger le dernier dataset statique sauvegardÃ© ou Ã©chantillonnÃ© dans <code>data/food.csv</code>, rendant le pipeline dâ€™intÃ©gration continue <strong>rapide et dÃ©terministe</strong>, sans dÃ©pendre de la disponibilitÃ© de lâ€™API externe.</p></li>
<li><p><strong>TolÃ©rance aux pannes :</strong> IntÃ©gration de mÃ©canismes de â€œretryâ€ en cas dâ€™erreur HTTP.<br>
<em>Pourquoi ?</em> Assure que la constitution du dataset ne sâ€™arrÃªte pas Ã  la moindre micro-coupure rÃ©seau, garantissant une collecte complÃ¨te des 500 produits visÃ©s par catÃ©gorie.</p></li>
</ul>
<div id="1b06b5df" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>saved_dataset <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>df_final <span class="op">=</span> downloader(saved_dataset) <span class="co"># Data cleaning encapsulÃ© au sein mÃªme de l'Ã©tape de tÃ©lÃ©chargement des donnÃ©es</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>ğŸŒ Lancement de la collecte
ğŸ¤– Utilisation du dataset 
--------------------------------------------------
ğŸš€ DATASET FINAL : 2980 produits.
--------------------------------------------------
RÃ©partition par CatÃ©gorie :
Category_Label
CÃ©rÃ©ales         482
LÃ©gumineuses     439
Biscuits         406
LÃ©gumes          400
Pizzas           393
Chocolats        336
Jus de Fruits    310
Fromages         214
Name: count, dtype: int64

RÃ©partition par Nutriscore :
Nutriscore
A    669
B    336
C    829
D    601
E    545
Name: count, dtype: int64</code></pre>
</div>
</div>
</section>
<section id="sÃ©lection-des-catÃ©gories" class="level3">
<h3 class="anchored" data-anchor-id="sÃ©lection-des-catÃ©gories">ğŸ¥— SÃ©lection des CatÃ©gories</h3>
<p>Nous avons dÃ©libÃ©rÃ©ment ciblÃ© 8 catÃ©gories hÃ©tÃ©rogÃ¨nes (des <em>LÃ©gumes</em> aux <em>Pizzas</em> en passant par les <em>Chocolats</em>) pour maximiser la reprÃ©sentativitÃ© du dataset :</p>
<ul>
<li><strong>Couverture du spectre nutritionnel :</strong> Cette sÃ©lection garantit une distribution variÃ©e des <strong>Nutriscores (de A Ã  E)</strong> et des groupes <strong>NOVA</strong>, nous permettant de comparer des produits bruts (sains) Ã  des produits ultra-transformÃ©s.</li>
<li><strong>VariÃ©tÃ© des attributs :</strong> En mixant boissons, plats prÃ©parÃ©s, produits secs et frais, nous capturons un large Ã©ventail de valeurs nutritionnelles (taux de sucre, gras, protÃ©ines), ce qui est indispensable pour Ã©viter les biais dâ€™analyse sur un seul type dâ€™aliment.</li>
</ul>
<p>Nous pouvons observÃ© que nous avons obtenu un dataset Ã©quilibrÃ© oÃ¹ les produits de chaque catÃ©gorie sont reprÃ©sentÃ©s en grand nombre avec un mÃªme ordre de grandeur.</p>
</section>
<section id="sÃ©lection-des-variables-explicatives" class="level3">
<h3 class="anchored" data-anchor-id="sÃ©lection-des-variables-explicatives">ğŸ§ª SÃ©lection des variables explicatives</h3>
<p>Pour garantir la performance du modÃ¨le, nous avons retenu un vecteur de <strong>8 variables quantitatives</strong> et <strong>1 variable catÃ©gorielle</strong>, divisÃ©es en trois groupes stratÃ©giques reflÃ©tant la logique officielle du Nutri-Score.</p>
<section id="les-composantes-nÃ©gatives-pÃ©nalisantes-pour-le-nutri-score-Ã -priori" class="level4">
<h4 class="anchored" data-anchor-id="les-composantes-nÃ©gatives-pÃ©nalisantes-pour-le-nutri-score-Ã -priori">1. Les composantes nÃ©gatives (pÃ©nalisantes pour le nutri-score Ã  priori)</h4>
<p>Le Nutri-Score fonctionne par accumulation de â€œpoints nÃ©gatifsâ€ (N). Pour imiter ce comportement, nous avons sÃ©lectionnÃ© :</p>
<ul>
<li><strong><code>nutriments.energy-kcal_100g</code></strong> : La densitÃ© Ã©nergÃ©tique est le premier facteur de pÃ©nalitÃ©.
<ul>
<li>Les variantes en kJ ont Ã©tÃ© Ã©cartÃ©es pour Ã©viter la colinÃ©aritÃ© parfaite (redondance dâ€™information).</li>
</ul></li>
<li><strong><code>nutriments.sugars_100g</code></strong> (Sucres totaux) :
<ul>
<li>Lâ€™algorithme actuel sanctionne les sucres totaux. Utiliser les sucres ajoutÃ©s (<code>added-sugars</code>) aurait induit le modÃ¨le en erreur sur les produits naturellement sucrÃ©s (ex: jus de fruits).</li>
</ul></li>
<li><strong><code>nutriments.saturated-fat_100g</code></strong> (Acides gras saturÃ©s) :
<ul>
<li>Nous avons dÃ©libÃ©rÃ©ment choisi les graisses saturÃ©es et non les graisses totales (<code>fat_100g</code>). Un produit peut Ãªtre gras mais sain (ex: Huile de noix).</li>
</ul></li>
<li><strong><code>nutriments.sodium_100g</code></strong></li>
</ul>
</section>
<section id="les-composantes-positives-valorisantes-pour-le-nutri-score-Ã -priori" class="level4">
<h4 class="anchored" data-anchor-id="les-composantes-positives-valorisantes-pour-le-nutri-score-Ã -priori">2. Les composantes Positives (valorisantes pour le nutri-score Ã  priori)</h4>
<p>Le score est attÃ©nuÃ© par des â€œpoints positifsâ€ (P). Sans ces variables, le modÃ¨le ne peut pas expliquer pourquoi une pizza classÃ©e B est meilleure quâ€™une autre classÃ©e D.</p>
<ul>
<li><strong><code>nutriments.fiber_100g</code></strong> (Fibres)</li>
<li><strong><code>nutriments.proteins_100g</code></strong> (ProtÃ©ines)</li>
<li><strong><code>nutriments.fruits-vegetables-nuts-estimate-from-ingredients_100g</code></strong> :
<ul>
<li>Variable souvent latente (estimÃ©e). Sans elle, le modÃ¨le Ã©choue systÃ©matiquement Ã  prÃ©dire correctement les classes A et B des produits transformÃ©s mixtes (plats prÃ©parÃ©s).</li>
</ul></li>
</ul>
</section>
<section id="la-variable-de-contextualisation" class="level4">
<h4 class="anchored" data-anchor-id="la-variable-de-contextualisation">3. La variable de contextualisation</h4>
<ul>
<li><strong><code>Category_Label</code></strong> (CatÃ©gorie du produit) :
<ul>
<li>Le calcul du Nutri-Score nâ€™est pas universel (grilles distinctes pour les â€œMatiÃ¨res grassesâ€, â€œBoissonsâ€ et â€œFromagesâ€).</li>
<li><em>Impact ML :</em> Cette variable permet aux algorithmes non-linÃ©aires (comme le Random Forest) de crÃ©er des embranchements conditionnels (ex: <em>â€œSi Fromage, alors tolÃ©rer plus de grasâ€</em>).</li>
</ul></li>
</ul>
</section>
<section id="justification-des-variables-rejetÃ©es" class="level4">
<h4 class="anchored" data-anchor-id="justification-des-variables-rejetÃ©es">ğŸš« Justification des variables rejetÃ©es</h4>
<p>Lâ€™exclusion de variables est cruciale pour rÃ©duire le bruit et garantir la robustesse du modÃ¨le.</p>
<section id="a.-Ã©limination-du-bruit-micronutriments" class="level5">
<h5 class="anchored" data-anchor-id="a.-Ã©limination-du-bruit-micronutriments">A. Ã‰limination du Bruit (Micronutriments)</h5>
<p>Nous avons exclu : <code>vitamin-c</code>, <code>calcium</code>, <code>iron</code>, <code>magnesium</code>, etc. &gt; Bien que vitaux, ces micronutriments nâ€™entrent pas dans la formule du Nutri-Score. Les inclure crÃ©erait des corrÃ©lations fallacieuses (ex: le modÃ¨le associerait â€œVitamine Câ€ Ã  â€œBon scoreâ€ uniquement parce que les fruits en contiennent, faussant lâ€™analyse causale).</p>
</section>
<section id="b.-standardisation-des-unitÃ©s-biais-dÃ©chelle" class="level5">
<h5 class="anchored" data-anchor-id="b.-standardisation-des-unitÃ©s-biais-dÃ©chelle">B. Standardisation des UnitÃ©s (Biais dâ€™Ã©chelle)</h5>
<p>Nous avons exclu toutes les colonnes <code>_serving</code> (par portion) et <code>_unit</code>. &gt; Pour que le Machine Learning soit viable, les donnÃ©es doivent Ãªtre comparables. Comparer 100g de biscuits Ã  une portion de 30g introduirait un biais mathÃ©matique majeur. Nous travaillons exclusivement sur la base normalisÃ©e <strong>Standard 100g</strong>.</p>
</section>
<section id="c.-prÃ©vention-de-la-fuite-de-donnÃ©es-data-leakage" class="level5">
<h5 class="anchored" data-anchor-id="c.-prÃ©vention-de-la-fuite-de-donnÃ©es-data-leakage">C. PrÃ©vention de la Fuite de DonnÃ©es (Data Leakage)</h5>
<p>Nous avons exclu : <code>nutriscore_score</code> (le score numÃ©rique brut). &gt; Câ€™est la rÃ©ponse Ã  lâ€™Ã©quation (Target). Donner le score numÃ©rique au modÃ¨le pour prÃ©dire la classe (A-E) donnerait une prÃ©cision artificielle de 100%, mais le modÃ¨le nâ€™aurait rien appris sur la composition nutritionnelle rÃ©elle.</p>
</section>
</section>
</section>
</section>
<section id="exploration-les-surprises-du-dataset" class="level2">
<h2 class="anchored" data-anchor-id="exploration-les-surprises-du-dataset">4. Exploration : Les surprises du dataset</h2>
<p>On peut observer la distribution des produits par nutriscore avec leurs teneurs pour chaque nutriment. On voit que le sucre, le gras, la graisse saturÃ©e ont lâ€™air dâ€™avoir comme on pouvait lâ€™imaginer, un impact nÃ©gatif sur le Nutri-score.</p>
<p>Nous vous invitons Ã  consulter le graphe suivant pour Fruits et LÃ©gumes pour ainsi dÃ©couvrir que cette variable Ã  lâ€™air dâ€™Ãªtre assez dÃ©terminante statistiquement pour obtenir un Nutri-score positif A B ou C.</p>
<div id="61b5648f" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>distribution_nutriments_nutriscore(df_final)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>ğŸ” Analyse dÃ©taillÃ©e par nutriment :</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"93bcaafc36ad408d92db10e9c183141c","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<p><strong>Lâ€™exemple du sucre</strong></p>
<p><strong>Le schÃ©ma suivant montre bien que</strong> la relation entre le taux de sucre et le Nutriscore nâ€™est pas strictement binaire.</p>
<p>En observant la distribution, on constate que si une teneur en sucre &gt; 20g (zone rouge) est <em>majoritairement</em> corrÃ©lÃ©e Ã  un Nutriscore dÃ©favorable D ou E, cette rÃ¨gle nâ€™est pas absolue. Des points aberrants (outliers) apparaissent dans des scores plus favorables C, probablement sauvÃ©s par leur teneur en Fruit et LÃ©gumes.</p>
<p>Câ€™est cette â€œzone griseâ€ qui nous donne envie dâ€™utiliser un modÃ¨le de machine learning particulier, un <strong>Random Forest</strong>. Il est capable de segmenter ces cas limites en appliquant des rÃ¨gles conditionnelles successives pour dÃ©terminer comment le Nutriscore arbitre ces compensations nutritionnelles.</p>
<div id="44e72aa6" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>impact_matrix_sugar(df_final).show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Unable to display output for mime type(s): application/vnd.plotly.v1+json</code></pre>
</div>
</div>
<p>La Heatmap ci-dessous nous permet de valider la cohÃ©rence nutritionnelle du dataset et dâ€™anticiper les comportements du modÃ¨le :</p>
<ul>
<li><strong>Forte multicollinÃ©aritÃ© (redondance) :</strong> On observe une corrÃ©lation trÃ¨s Ã©levÃ©e (<strong>0.86</strong>) entre <em>Gras</em> et <em>SaturÃ©s</em>, ainsi quâ€™entre <em>Energie</em> et <em>Gras</em> (<strong>0.83</strong>). Cela est logique (le gras est le macronutriment le plus calorique), mais cela indique que ces variables apportent une information trÃ¨s similaire.</li>
<li><strong>Lâ€™indÃ©pendance du sel :</strong> Le <em>Sel</em> est une variable quasi-orthogonale (corrÃ©lations proches de 0 partout). Câ€™est une excellente nouvelle : cela signifie quâ€™il apporte une information unique et complÃ©mentaire pour la prÃ©diction.</li>
<li><strong>Opposition structurelle :</strong> La corrÃ©lation nÃ©gative entre <em>Fruits/LÃ©gumes</em> et <em>Energie</em> (<strong>-0.61</strong>) confirme que les aliments sains sont structurellement moins denses en calories.</li>
</ul>
<div id="485e9a73" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>corr_matrix(df_final).show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Unable to display output for mime type(s): application/vnd.plotly.v1+json</code></pre>
</div>
</div>
<p>La rÃ©partition des scores par famille dâ€™aliments confirme la nÃ©cessitÃ© dâ€™inclure la catÃ©gorie comme variable explicative :</p>
<ul>
<li><strong>Polarisation des CatÃ©gories :</strong> Certaines familles sont des prÃ©dicteurs forts Ã  elles seules.
<ul>
<li>Les <em>LÃ©gumineuses</em> et <em>LÃ©gumes</em> sont massivement classÃ©s <strong>A ou B</strong> (Vert).</li>
<li>Les <em>Chocolats</em> et <em>Biscuits</em> saturent les classes <strong>D et E</strong> (Rouge/Orange).</li>
</ul></li>
<li><strong>La Zone Grise (Variance Intra-classe) :</strong> Câ€™est ici que le Machine Learning devient indispensable.
<ul>
<li>Regardez les <strong>CÃ©rÃ©ales</strong> : elles couvrent tout le spectre, du A au E.</li>
<li>Les <strong>Pizzas</strong> et <strong>Jus de Fruits</strong> oscillent principalement entre C et D, mais avec des exceptions notables.</li>
<li><em>Conclusion :</em> La catÃ©gorie seule ne suffit pas Ã  prÃ©dire le score. Le modÃ¨le devra analyser la composition fine (fibres, sucres) pour classer correctement ces produits â€œmixtesâ€.</li>
</ul></li>
</ul>
<div id="4f0562ff" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>distribution_nutriscore_par_famille_d_aliments(df_final).show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Unable to display output for mime type(s): application/vnd.plotly.v1+json</code></pre>
</div>
</div>
<p>Ce graphique en barres empilÃ©es montre la rÃ©partition des scores pour les marques les plus frÃ©quentes. * <strong>Marques SpÃ©cialistes vs GÃ©nÃ©ralistes :</strong> * Les marques de confiserie (Milka, Lindt, Cadbury) sont quasi-exclusivement rouges/oranges. * Les marques distributeurs (Carrefour, Marque RepÃ¨re, Sainsburyâ€™s) prÃ©sentent un profil trÃ¨s variÃ©, reflÃ©tant leur catalogue diversifiÃ©. * <strong>Risque de Biais (Data Leakage) :</strong> * Si nous utilisions la variable â€œMarqueâ€ pour lâ€™entraÃ®nement, le modÃ¨le pourrait apprendre paresseusement : <em>â€œSi Milka, alors Eâ€</em>. * <em>DÃ©cision :</em> Nous avons exclu la marque des variables explicatives. Le but est que le modÃ¨le juge un produit sur sa <strong>composition nutritionnelle</strong> (le taux de sucre), et non sur son Ã©tiquette commerciale. Cela garantit que le modÃ¨le pourra noter correctement une nouvelle marque inconnue Ã  lâ€™avenir.</p>
<div id="2047b874" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>nutriscore_par_marques(df_final).show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<pre><code>Unable to display output for mime type(s): application/vnd.plotly.v1+json</code></pre>
</div>
</div>
<p><strong>1. Distribution du Sucre par Score (Boxplot) :</strong> * <strong>Chevauchement des Classes :</strong> On remarque que le Nutri-Score <strong>D</strong> possÃ¨de une Ã©tendue trÃ¨s vaste (jusquâ€™Ã  59.7g de sucre), dÃ©passant largement les mÃ©dianes des classes supÃ©rieures. * <strong>La â€œBasculeâ€ du Score E :</strong> La boÃ®te Ã  moustaches du score <strong>E</strong> commence lÃ  oÃ¹ les autres sâ€™arrÃªtent (mÃ©diane Ã  35g), confirmant que le sucre est un â€œaccÃ©lÃ©rateurâ€ de mauvaise note, mais quâ€™il nâ€™est pas le seul critÃ¨re de discrimination pour les scores intermÃ©diaires.</p>
<p><strong>2. Cartographie Gras vs Sucre (Scatter Plot) :</strong> * <strong>Zones de DensitÃ© :</strong> Le nuage de points montre une saturation de produits <strong>D (Orange)</strong> et <strong>E (Rouge)</strong> dans les zones Ã  haute teneur en gras (&gt;30g) ou en sucre (&gt;40g). * <strong>Lâ€™Exceptions des â€œBonsâ€ Scores :</strong> Les produits <strong>A et B</strong> (en vert) sont quasi-exclusivement confinÃ©s dans le coin infÃ©rieur gauche (faible en gras ET faible en sucre). * <strong>Non-LinÃ©aritÃ© :</strong> De nombreux produits avec un taux de gras moyen (20-30g) se retrouvent Ã©parpillÃ©s entre les scores B, C et D. Cela prouve que des variables â€œcorrectricesâ€ (fibres, protÃ©ines, pourcentage de fruits) jouent un rÃ´le de balance, empÃªchant une classification par simple rÃ©gression.</p>
<div id="5427fd9a" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>sucre_gras(df_final)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>ğŸ‘‡ Change de catÃ©gorie pour mettre Ã  jour instantanÃ©ment :</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"928fb1cff50c41f496eecc37df5f2f40","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<section id="conclusion-de-lanalyse-exploratoire-des-donnÃ©es" class="level4">
<h4 class="anchored" data-anchor-id="conclusion-de-lanalyse-exploratoire-des-donnÃ©es">ğŸ’¡ Conclusion de lâ€™analyse exploratoire des donnÃ©es</h4>
<p>Lâ€™ensemble de ces visualisations confirme trois points clÃ©s pour la suite de notre projet :</p>
<ol type="1">
<li><strong>Le Nutriscore est multi-factoriel :</strong> Aucune variable seule (sucre, gras ou calories) ne permet de prÃ©dire le score avec certitude. Câ€™est lâ€™interaction entre les bonus (fibres, protÃ©ines, fruits) et les malus qui crÃ©e la note finale.</li>
<li><strong>La CatÃ©gorie est un pivot :</strong> Un mÃªme taux de sucre nâ€™aura pas le mÃªme impact sur une cÃ©rÃ©ale que sur un fromage. Lâ€™inclusion du <code>Category_Label</code> dans notre modÃ¨le sera dÃ©terminante.</li>
<li><strong>Le choix du Random Forest est validÃ© :</strong> Face Ã  la forte colinÃ©aritÃ© des nutriments et aux seuils de bascule visibles sur les boxplots (ex: le sucre chez les chocolats), un algorithme capable de crÃ©er des rÃ¨gles de dÃ©cision non-linÃ©aires est lâ€™outil idÃ©al.</li>
</ol>
</section>
</section>
<section id="modÃ©lisation-expliquer-plutÃ´t-que-prÃ©dire" class="level2">
<h2 class="anchored" data-anchor-id="modÃ©lisation-expliquer-plutÃ´t-que-prÃ©dire">5. ğŸŒ² ModÃ©lisation : Expliquer plutÃ´t que prÃ©dire</h2>
<section id="notre-approche-classification-supervisÃ©e" class="level3">
<h3 class="anchored" data-anchor-id="notre-approche-classification-supervisÃ©e">Notre approche : Classification supervisÃ©e</h3>
<p>Le problÃ¨me est traitÃ© comme une classification multiclasse (A, B, C, D, E). Lâ€™objectif est de rÃ©tro-ingÃ©nierier la logique mathÃ©matique de la notation.</p>
</section>
<section id="le-choix-de-larme-random-forest" class="level3">
<h3 class="anchored" data-anchor-id="le-choix-de-larme-random-forest">Le choix de lâ€™arme : Random Forest</h3>
<p>Nous avons privilÃ©giÃ© la <strong>ForÃªt AlÃ©atoire</strong> pour trois raisons : 1. <strong>Logique par seuils :</strong> Les arbres de dÃ©cision imitent parfaitement la structure de rÃ¨gles â€œSiâ€¦ Alorsâ€¦â€ de lâ€™algorithme officiel. 2. <strong>RÃ©sistance Ã  la multicollinÃ©aritÃ© :</strong> Le Random Forest gÃ¨re naturellement les variables corrÃ©lÃ©es (ex: Ã‰nergie vs Gras) identifiÃ©es lors de lâ€™EDA. 3. <strong>InterprÃ©tabilitÃ© :</strong> GrÃ¢ce au <code>feature_importance</code>, nous pouvons quantifier lâ€™impact rÃ©el de chaque nutriment sur la note finale.</p>
<blockquote class="blockquote">
<p><strong>Note sur lâ€™interprÃ©tation :</strong> Une attention particuliÃ¨re est portÃ©e Ã  la lecture de lâ€™importance des variables, car lâ€™impact des variables colinÃ©aires peut Ãªtre rÃ©parti arbitrairement entre elles.</p>
</blockquote>
<div id="1c075f58" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> food_analyzer.predictor <span class="im">import</span> NutriModel</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialisation</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>predictor <span class="op">=</span> NutriModel(df_final)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>scores_history <span class="op">=</span> {} </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 1ï¸âƒ£ TRAIN / </span><span class="al">TEST</span><span class="co"> NORMAL (La Baseline)</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">ğŸŸ¦ --- Ã‰TAPE 1 : BASELINE SIMPLE ---"</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>predictor.prepare_data(include_categorical<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>predictor.train()</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>scores_history[<span class="st">'1. Baseline'</span>] <span class="op">=</span> predictor.evaluate(method<span class="op">=</span><span class="st">"cross_val"</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co"># ğŸ“Š VUE 1 : Comment rÃ©flÃ©chit le modÃ¨le "naÃ¯f" ?</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>predictor.plot_feature_importance(top_n<span class="op">=</span><span class="dv">15</span>, custom_title<span class="op">=</span><span class="st">"1. Importance des Features (ModÃ¨le NaÃ¯f)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
ğŸŸ¦ --- Ã‰TAPE 1 : BASELINE SIMPLE ---
ğŸ‘¶ Mode BASIC : Utilisation des nutriments bruts.
âœ… Dataset prÃªt : 16 variables en entrÃ©e.
ğŸ“Š CV Score : 86.78% (+/- 1.02%)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="main_files/figure-html/cell-11-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Lâ€™analyse de lâ€™importance des variables pour le <strong>ModÃ¨le NaÃ¯f</strong> rÃ©vÃ¨le une hiÃ©rarchie claire dans la prÃ©diction du Nutriscore :</p>
<section id="variables-dÃ©terminantes-impact-majeur" class="level4">
<h4 class="anchored" data-anchor-id="variables-dÃ©terminantes-impact-majeur">1. Variables dÃ©terminantes (Impact Majeur)</h4>
<ul>
<li><strong>Sucre (~20%)</strong> : Le prÃ©dicteur dominant. Une variation du taux de sucre est le facteur le plus susceptible de modifier la classe prÃ©dite.</li>
<li><strong>Effet CombinÃ© (Gras / Ã‰nergie / SaturÃ©s)</strong> : Ces trois variables agissent de concert. Bien que lâ€™<strong>Ã‰nergie (~11%)</strong> et les <strong>Acides Gras SaturÃ©s (~13%)</strong> soient isolÃ©s dans le graphique, ils sont intrinsÃ¨quement liÃ©s aux <strong>Gras (~8%)</strong>, formant un bloc de pÃ©nalitÃ© cohÃ©rent.</li>
<li><strong>Sel (~13%)</strong> : ComplÃ¨te le trio des variables â€œcritiquesâ€ avec un impact direct et Ã©levÃ©.</li>
</ul>
</section>
<section id="variables-Ã -impact-moyen" class="level4">
<h4 class="anchored" data-anchor-id="variables-Ã -impact-moyen">2. Variables Ã  impact moyen</h4>
<ul>
<li><strong>ProtÃ©ines &amp; Fibres </strong> : Impact modÃ©rÃ©, agissant comme contrepoids positif (bonus) dans lâ€™algorithme de calcul pour amÃ©liorer le score final.</li>
<li><strong>Fruits &amp; LÃ©gumes</strong> : Moindre influence sur les dÃ©cisions du modÃ¨le, possiblement due Ã  une plus faible variabilitÃ© dans le jeu de donnÃ©es.</li>
</ul>
</section>
<section id="variables-un-peu-plus-faible" class="level4">
<h4 class="anchored" data-anchor-id="variables-un-peu-plus-faible">3. Variables un peu plus faible</h4>
<p>Lâ€™observation du graphique montre que les variables issues du <strong>One-Hot Encoding</strong> (les labels de catÃ©gories de produits) affichent systÃ©matiquement un impact plus faible que les variables numÃ©riques :</p>
<ul>
<li><strong>Dilution de lâ€™Information</strong> : En transformant une colonne â€œCatÃ©gorieâ€ en plusieurs colonnes binaires (0 ou 1), lâ€™importance statistique est fragmentÃ©e. Chaque catÃ©gorie individuelle pÃ¨se moins lourd que les variables continues comme le Sucre ou lâ€™Ã‰nergie.</li>
<li><strong>UniversalitÃ© des nutriments</strong> : Le faible impact des variables catÃ©gorielles suggÃ¨re que le modÃ¨le privilÃ©gie les <strong>valeurs nutritionnelles intrinsÃ¨ques</strong> plutÃ´t que lâ€™appartenance Ã  une catÃ©gorie spÃ©cifique. En clair, le modÃ¨le â€œcomprendâ€ quâ€™un produit est mal classÃ© Ã  cause de son taux de sucre, peu importe quâ€™il sâ€™agisse dâ€™un soda ou dâ€™un biscuit.</li>
<li><strong>Biais de variabilitÃ©</strong> : La plupart des catÃ©gories encodÃ©es sont trÃ¨s spÃ©cifiques et ne concernent quâ€™une petite portion du dataset, ce qui limite leur pouvoir prÃ©dictif global par rapport aux nutriments prÃ©sents dans 100% des produits.</li>
</ul>
</section>
</section>
<section id="analyse-de-la-performance-validation-croisÃ©e" class="level3">
<h3 class="anchored" data-anchor-id="analyse-de-la-performance-validation-croisÃ©e">ğŸ“ˆ Analyse de la Performance (Validation CroisÃ©e)</h3>
<p>Le modÃ¨le affiche un score de <strong>86.78%</strong> avec un Ã©cart-type de <strong>+/- 1.02%</strong>.</p>
<ul>
<li><strong>Performance ElevÃ©e</strong> : Un score de ~87% indique que le modÃ¨le possÃ¨de une excellente capacitÃ© prÃ©dictive pour classer correctement les produits selon leur Nutriscore.</li>
<li><strong>Grande StabilitÃ©</strong> : Lâ€™Ã©cart-type trÃ¨s faible (1.02%) prouve que les performances sont consistantes. Le modÃ¨le ne dÃ©pend pas dâ€™un Ã©chantillon de donnÃ©es spÃ©cifique et ne prÃ©sente pas de signe de surapprentissage (overfitting) marquÃ©.</li>
<li><strong>FiabilitÃ©</strong> : Cette robustesse statistique confirme que les conclusions tirÃ©es sur lâ€™importance des features (Sucre, Ã‰nergie, SaturÃ©s) sâ€™appuient sur un modÃ¨le fiable et gÃ©nÃ©ralisable.</li>
</ul>
</section>
<section id="loptimisation-des-hyperparamÃ¨tres-tuning" class="level3">
<h3 class="anchored" data-anchor-id="loptimisation-des-hyperparamÃ¨tres-tuning">âš™ï¸ Lâ€™Optimisation des HyperparamÃ¨tres (Tuning)</h3>
<p>Lâ€™<strong>Hyperparameter Tuning</strong> consiste Ã  rÃ©gler manuellement les curseurs dâ€™un modÃ¨le pour maximiser ses performances.</p>
<ul>
<li><strong>ParamÃ¨tres vs HyperparamÃ¨tres</strong> : Les paramÃ¨tres sont appris par le modÃ¨le (poids), tandis que les hyperparamÃ¨tres sont configurÃ©s <strong>avant</strong> lâ€™entraÃ®nement (ex: profondeur dâ€™un arbre).</li>
<li><strong>Objectif</strong> : Trouver le rÃ©glage optimal pour Ã©viter le sur-apprentissage (trop complexe) ou le sous-apprentissage (trop simple).</li>
<li><strong>MÃ©thodes</strong> : On utilise gÃ©nÃ©ralement un <strong>Grid Search</strong> (test de toutes les combinaisons) ou un <strong>Random Search</strong> (test alÃ©atoire) pour identifier la meilleure configuration.</li>
</ul>
<p><strong>En rÃ©sumÃ©</strong> : Câ€™est le passage du rÃ©glage â€œpar dÃ©fautâ€ au rÃ©glage â€œsur mesureâ€ pour gagner en prÃ©cision et en stabilitÃ©.</p>
<p>Nous testons un GridSearch dans la prochaine cellule.</p>
<div id="231640f8" class="cell" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1 HYPERPARAMÃˆTRES (Optimisation du modÃ¨le de base)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">ğŸŸ¨ --- Ã‰TAPE 2 : TUNING DU MODÃˆLE BASELINE ---"</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>predictor.optimize_hyperparameters()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>scores_history[<span class="st">'2. Baseline Tuned'</span>] <span class="op">=</span> predictor.evaluate(method<span class="op">=</span><span class="st">"cross_val"</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ğŸ“Š VUE 2 : Est-ce que le tuning change la logique ?</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>predictor.plot_feature_importance(top_n<span class="op">=</span><span class="dv">15</span>, custom_title<span class="op">=</span><span class="st">"2. Importance aprÃ¨s Tuning (Sans Smart Features)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
ğŸŸ¨ --- Ã‰TAPE 2 : TUNING DU MODÃˆLE BASELINE ---
ğŸ”§ Optimisation en cours (Patience...)...
Fitting 3 folds for each of 24 candidates, totalling 72 fits
ğŸ‰ Meilleurs params : {'max_depth': 15, 'min_samples_leaf': 1, 'min_samples_split': 2, 'n_estimators': 100}
ğŸ“Š CV Score : 86.34% (+/- 0.96%)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="main_files/figure-html/cell-12-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Le tuning ne change pas vraiment le rÃ©sultat prÃ©cÃ©dent, câ€™est pourquoi on a eu lâ€™idÃ©e de crÃ©er de nouvelles features pour essayer dâ€™avoir une meilleure prÃ©dictibilitÃ©.</p>
</section>
<section id="le-feature-engineering-lintelligence-mÃ©tier" class="level3">
<h3 class="anchored" data-anchor-id="le-feature-engineering-lintelligence-mÃ©tier">ğŸ› ï¸ Le Feature Engineering : Lâ€™Intelligence MÃ©tier</h3>
<p>Câ€™est ici que notre projet se distingue. Pour dÃ©passer le plafond de performance de nos modÃ¨les (~86%), nous avons enrichi le jeu de donnÃ©es en injectant des connaissances mÃ©tier (SantÃ© Publique France sur le calcul du nutriscore) directement dans lâ€™apprentissage, pour voir si cela amÃ©liorait nos performances (BONUS).</p>
<section id="nos-smart-features" class="level4">
<h4 class="anchored" data-anchor-id="nos-smart-features">ğŸ§  Nos â€œSmart Featuresâ€</h4>
<ul>
<li><strong>Contextualisation (Ratios)</strong> :
<ul>
<li><em>Variables :</em> <code>Ratio_Sucre_Energie</code> et <code>Ratio_Gras_Energie</code>.<br>
</li>
<li><em>Objectif :</em> Permettre au modÃ¨le de comprendre la <strong>densitÃ© nutritionnelle</strong>. 10g de sucre nâ€™ont pas le mÃªme impact dans un biscuit hypercalorique que dans une boisson oÃ¹ ils reprÃ©sentent 100% de lâ€™apport Ã©nergÃ©tique.</li>
</ul></li>
<li><strong>Simulation des composantes</strong> :
<ul>
<li><em>Variables :</em> <code>Est_Points_Negatifs</code> (somme pondÃ©rÃ©e Ã‰nergie, SaturÃ©s, Sucre, Sel) et <code>Est_Points_Positifs</code> (Fibres, ProtÃ©ines, Fruits).<br>
</li>
<li><em>Objectif :</em> Projeter les nutriments bruts sur une Ã©chelle linÃ©aire directement comparable Ã  celle du Nutriscore officiel.</li>
</ul></li>
<li><strong>Score final estimÃ©</strong> :
<ul>
<li><em>Variable :</em> <code>Est_Score_Final</code> <strong>$ = Points_NÃ©gatifs - Points_Positifs$</strong>.<br>
</li>
<li><em>Objectif :</em> Agir comme un <strong>â€œindice fortâ€</strong>. Le modÃ¨le ne perd plus dâ€™Ã©nergie Ã  rÃ©apprendre lâ€™arithmÃ©tique de base et peut se concentrer sur la classification fine des <strong>cas limites</strong> (ex: produits frontiÃ¨res entre C et D).</li>
</ul></li>
</ul>
<section id="sources-et-rÃ©fÃ©rences" class="level5">
<h5 class="anchored" data-anchor-id="sources-et-rÃ©fÃ©rences">ğŸ“š Sources et RÃ©fÃ©rences</h5>
<p>Les coefficients de simulation et les constantes de densitÃ© Ã©nergÃ©tique utilisÃ©s dans ce projet sâ€™appuient sur les rÃ©fÃ©rentiels suivants :</p>
<p>BasÃ© sur le <em>QUESTIONS- REPONSES SUR LE NUTRI-SCORE</em>. Les diviseurs (ex: 335 pour lâ€™Ã©nergie, 4.5 pour le sucre) correspondent aux seuils dâ€™attribution des points de pÃ©nalitÃ© et de bonus.</p>
<p>https://nutrition.coeur-herault.fr/sites/default/files/files/fichiers/qr_scientifique_technique_nutriscore-120320.pdf</p>
<p>Ces coefficients simulent la logique de base du Nutri-Score (algorithme 2017) et lâ€™algorithme 2024 a affinÃ© certains de ces seuils pour Ãªtre plus exigeant.</p>
</section>
<section id="impact-sur-le-modÃ¨le" class="level5">
<h5 class="anchored" data-anchor-id="impact-sur-le-modÃ¨le">ğŸš€ Impact sur le ModÃ¨le</h5>
<blockquote class="blockquote">
<p><strong>Le modÃ¨le ne cherche plus seulement des corrÃ©lations : il apprend Ã  affiner une formule quâ€™on lui a partiellement â€œmÃ¢chÃ©eâ€.</strong> &gt;</p>
</blockquote>
<div id="cb4816ac" class="cell" data-execution_count="12">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 3 FEATURE ENGINEERING (Le Game Changer)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">ğŸŸ© --- Ã‰TAPE 3 : AJOUT DES SMART FEATURES ---"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. On injecte les calculs</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>predictor.add_smart_features()</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. On RE-PRÃ‰PARE les donnÃ©es</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>predictor.prepare_data(include_categorical<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. On RE-ENTRAÃNE</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>predictor.train() </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>scores_history[<span class="st">'3. Smart Features'</span>] <span class="op">=</span> predictor.evaluate(method<span class="op">=</span><span class="st">"cross_val"</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co"># ğŸ“Š VUE 3 : Le modÃ¨le a-t-il compris la formule ? (Regarde 'Est_Score_Final')</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>predictor.plot_feature_importance(top_n<span class="op">=</span><span class="dv">15</span>, custom_title<span class="op">=</span><span class="st">"3. Importance avec Smart Features"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
ğŸŸ© --- Ã‰TAPE 3 : AJOUT DES SMART FEATURES ---
ğŸ§  Injection des connaissances humaines (Smart Features)...
âœ… Colonnes calculÃ©es ajoutÃ©es !
ğŸ˜ Mode EXPERT : 5 smart features dÃ©tectÃ©es.
âœ… Dataset prÃªt : 21 variables en entrÃ©e.
ğŸ“Š CV Score : 88.09% (+/- 1.05%)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="main_files/figure-html/cell-13-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="a607ce26" class="cell" data-execution_count="13">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 4ï¸âƒ£ HYPERPARAMÃˆTRES FINAL (Optimisation du modÃ¨le Smart)</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">ğŸŸ§ --- Ã‰TAPE 4 : TUNING FINAL (SMART) ---"</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>predictor.optimize_hyperparameters()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>scores_history[<span class="st">'4. Smart Tuned'</span>] <span class="op">=</span> predictor.evaluate(method<span class="op">=</span><span class="st">"cross_val"</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ğŸ“Š VUE 4 : Le modÃ¨le ultime</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>predictor.plot_feature_importance(top_n<span class="op">=</span><span class="dv">15</span>, custom_title<span class="op">=</span><span class="st">"4. ModÃ¨le Final OptimisÃ©"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
ğŸŸ§ --- Ã‰TAPE 4 : TUNING FINAL (SMART) ---
ğŸ”§ Optimisation en cours (Patience...)...
Fitting 3 folds for each of 24 candidates, totalling 72 fits
ğŸ‰ Meilleurs params : {'max_depth': None, 'min_samples_leaf': 1, 'min_samples_split': 2, 'n_estimators': 100}
ğŸ“Š CV Score : 88.09% (+/- 1.05%)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="main_files/figure-html/cell-14-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Le rÃ©sultat est sans appel :</strong> En nourrissant le modÃ¨le avec ces variables â€œmÃ©tierâ€, nous sommes passÃ©s dâ€™une prÃ©cision â€œplafondâ€ Ã  une meilleure comprÃ©hension de la logique avec un score bien supÃ©rieur.</p>
<div id="f7ea6573" class="cell" data-execution_count="14">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ğŸ† BILAN FINAL</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>bars <span class="op">=</span> plt.bar(scores_history.keys(), [s<span class="op">*</span><span class="dv">100</span> <span class="cf">for</span> s <span class="kw">in</span> scores_history.values()], </span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>               color<span class="op">=</span>[<span class="st">'blue'</span>, <span class="st">'orange'</span>, <span class="st">'green'</span>, <span class="st">'red'</span>])</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'PrÃ©cision (%)'</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Progression de la performance'</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">75</span>, <span class="dv">100</span>) </span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>plt.grid(axis<span class="op">=</span><span class="st">'y'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> bar <span class="kw">in</span> bars:</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    height <span class="op">=</span> bar.get_height()</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    plt.text(bar.get_x() <span class="op">+</span> bar.get_width()<span class="op">/</span><span class="dv">2</span>, height <span class="op">+</span> <span class="fl">0.5</span>, </span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>             <span class="ss">f"</span><span class="sc">{</span>height<span class="sc">:.2f}</span><span class="ss">%"</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="main_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
</section>
<section id="conclusion-gÃ©nÃ©rale-du-projet" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-gÃ©nÃ©rale-du-projet">ğŸ Conclusion gÃ©nÃ©rale du projet</h2>
<section id="analyse-de-la-progression-des-performances" class="level3">
<h3 class="anchored" data-anchor-id="analyse-de-la-progression-des-performances">ğŸ“ˆ Analyse de la Progression des Performances</h3>
<p>Lâ€™Ã©volution de la prÃ©cision du modÃ¨le dÃ©montre lâ€™efficacitÃ© de notre approche mÃ©thodologique :</p>
<ul>
<li><strong>Baseline (86.78%)</strong> : Le modÃ¨le initial prÃ©sente dÃ©jÃ  une excellente performance, confirmant que les donnÃ©es brutes contiennent lâ€™essentiel du signal nÃ©cessaire.</li>
<li><strong>Hyperparameter Tuning (86.34%)</strong> : Le lÃ©ger recul montre que les rÃ©glages par dÃ©faut Ã©taient dÃ©jÃ  optimaux pour ce dataset, que le modÃ¨le a prÃ©fÃ©rÃ© gÃ©nÃ©raliser, ou que cette Ã©tape eut Ã©tÃ© un peu dÃ©cevante.</li>
<li><strong>Apport du Feature Engineering (88.09%)</strong> : Lâ€™introduction des <strong>â€œSmart Featuresâ€</strong> (ratios et estimation du score) a permis de briser le plafond de verre des 87%. Lâ€™injection de logique mÃ©tier est ici plus puissante que la simple optimisation algorithmique.</li>
<li><strong>StabilitÃ© Finale</strong> : Le score final de <strong>88.09%</strong> avec un Ã©cart-type faible (+/- 1.02%) garantit un modÃ¨le robuste et fiable.</li>
</ul>
</section>
<section id="synthÃ¨se-de-lintelligence-du-modÃ¨le" class="level3">
<h3 class="anchored" data-anchor-id="synthÃ¨se-de-lintelligence-du-modÃ¨le">ğŸ§  SynthÃ¨se de lâ€™Intelligence du ModÃ¨le</h3>
<p>Lâ€™analyse de lâ€™importance des variables confirme que le modÃ¨le a parfaitement intÃ©grÃ© la hiÃ©rarchie nutritionnelle : 1. <strong>Le Sucre</strong> domine largement les prÃ©dictions (~20%), suivi des <strong>Graisses SaturÃ©es</strong> et du <strong>Sel</strong>. 2. Le modÃ¨le privilÃ©gie les <strong>nutriments universels</strong> plutÃ´t que les catÃ©gories de produits, assurant une classification basÃ©e sur la rÃ©alitÃ© biologique plutÃ´t que sur le marketing.</p>
<p><strong>En conclusion, ce projet dÃ©montre que lâ€™alliance entre le Machine Learning et lâ€™expertise en nutrition (via le Feature Engineering) permet dâ€™atteindre une prÃ©cision de prÃ¨s de 90%, offrant un outil dâ€™aide Ã  la dÃ©cision performant pour lâ€™industrie agroalimentaire et les consommateurs.</strong></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>